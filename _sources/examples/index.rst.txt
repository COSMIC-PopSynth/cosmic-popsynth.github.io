.. _examples:

########################################
Using COSMIC to evolve binaries with BSE
########################################


COSMIC can simulate binaries for several different use cases. Below 
you'll find examples to run a single binary system, multiple binary
systems or a grid of binaries.

For every evolved binary system, BSE generates two arrays:

* BCM - contains several binary parameters at user specified time steps during the binary's evolution. COSMIC's default is to output the final stage of the binary at the evolution time specified by the user.

* BPP - contains fewer binary paramters than BCM at important stages in the binary's evolution, including stellar evolutionary phase changes or mass transfer episodes.

The BCM and BPP are saved as Pandas DataFrames with the appropriate column
names assigned for each parameter. See Hurley et al (2002) for a detailed 
discussion of the BCM and BPP arrays.

See 'Running a Milky Way population' below for the process to simulate
a population of binaries consistent with a user-supplied star formation 
history for a single compact object population (e.g. BH-BH) or a range
of compact object populations (e.g. combinations of BH, NS, WD) as 
described in Breivik & Larson (2018).



*************************************
Creating and evolving a single binary
*************************************

Let's initialize and evolve a whopper of a binary that 
could have formed GW150914. First, we import the modules in COSMIC
that initialize and evolve the binary.

.. ipython::

    In [1]: from cosmic.sample.initialbinarytable import InitialBinaryTable

    In [2]: from cosmic.evolve import Evolve


To initialize the a single binary, we populate the SingleBinary method in the
InitialBinaryTable class. Each initialized binary requires several paramters:

* m1 : ZAMS mass of the primary star in :math:`M_{\odot}`

* m2 : ZAMS mass of the secondary star in :math:`M_{\odot}`

* porb : initial orbital period in days

* ecc : initial eccentricity

* tphysf : total evolution time of the binary in Myr

* kstar1 : initial primary stellar type, following the BSE convention

* kstar2 : initial secondary stellar type, following the BSE convention

* metallicity : metallicity fraction (e.g. :math:`Z_{\odot}=0.02`)
 
.. ipython::

    In [3]: single_binary = InitialBinaryTable.SingleBinary(m1=114.0, m2=45.0, porb=50.0, ecc=0.65, tphysf=13700.0, kstar1=1, kstar2=1, metallicity=0.002)

    In [4]: print(single_binary)

We also need to specify the flags for the various binary evolution prescriptions
used in BSE. Each flag is saved in the BSEDict dictionary. Note that the BSEDict
only needs to be specified the first time a binary is evolved with COSMIC or
if you need to change the binary evolution prescriptions. 

If you are unfamiliar with these prescriptions, it is highly 
advised to either run the defaults from the COSMIC install (which are consistent
with Dominik et al (2013)) or refer to Hurley et al (2002).

.. ipython::

    In [5]: BSEDict = {'xi': 0.5, 'bhflag': 1, 'neta': 0.5, 'windflag': 3, 'wdflag': 0, 'alpha1': 1.0, 'pts1': 0.05, 'pts3': 0.02, 'pts2': 0.01, 'epsnov': 0.001, 'hewind': 1.0, 'CK': -1000, 'bwind': 0.0, 'lambdaf': 1.0, 'mxns': 3.0, 'beta': -1.0, 'tflag': 1, 'acc2': 1.5, 'nsflag': 3, 'ceflag': 0, 'eddfac': 1.0, 'merger': 0, 'ifflag': 0, 'bconst': -3000, 'sigma': 265.0, 'gamma': -2.0}

Once we have the BSEDict and initialized binary, we can evolve the system with 
the evolve subroutine, which calls the evolv2.f subroutine in BSE. The evolve
subroutine returns the BCM and BPP arrays generated by BSE as DataFrames.

.. ipython:: 

    In [6]: EvolvedBinaryBPP, EvolvedBinaryBCM, initialConditions = Evolve.evolve(initialbinarytable=single_binary, BSEDict=BSEDict)

    In [7]: print(EvolvedBinaryBPP)

    In [8]: print(EvolvedBinaryBCM)

***************************************
Creating and evolving multiple binaries
***************************************

Now let's initialize and evolve systems that could form GW150914 and GW170817

.. ipython::

    In [9]: binary_set = InitialBinaryTable.MultipleBinary(m1=[114.0, 11.8], m2=[45.0, 11.1], porb=[50.0,2211.0], ecc=[0.65,0.55], tphysf=[13700.0,13700.0], kstar1=[1,1], kstar2=[1,1], metallicity=[0.002,0.02])

    In [10]: print(binary_set)

    In [11]: EvolvedBinariesBPP, EvolvedBinariesBCM, initialConditions  = Evolve.evolve(initialbinarytable=binary_set, BSEDict=BSEDict)

The BPP and BCM arrays are returned as pandas DataFrames which assign an index to each binary system we evolve. We can access each binary as follows

.. ipython:: 

    In [12]: print(EvolvedBinariesBPP.loc[0])

    In [13]: print(EvolvedBinariesBCM.loc[0])

    In [14]: print(EvolvedBinariesBPP.loc[1])

    In [15]: print(EvolvedBinariesBCM.loc[1])



****************************************
Creating and evolving a grid of binaries
****************************************

Sometimes it is helpful to run a grid of initial binaries to explore how
changing a single paramter affects the evolved binary. Here we will evolve 
the same system we ran for GW150914, but run over several initial orbital
periods spaced evenly in log space.

.. ipython::

    In [16]: n_grid = 10 

    In [17]: binary_grid = InitialBinaryTable.MultipleBinary(m1=np.ones(n_grid)*114.0, m2=np.ones(n_grid)*45.0, porb=np.logspace(0,4,n_grid), ecc=np.ones(n_grid)*0.65, tphysf=np.ones(n_grid)*13700.0, kstar1=np.ones(n_grid), kstar2=np.ones(n_grid), metallicity=np.ones(n_grid)*0.002)

    In [18]: print(binary_grid)

    In [19]: EvolvedBinariesBPP, EvolvedBinariesBCM, initialConditions  = Evolve.evolve(initialbinarytable=binary_grid, BSEDict=BSEDict)

    In [20]: print(EvolvedBinariesBPP)

    In [21]: print(EvolvedBinariesBCM)

